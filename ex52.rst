习题 52: 创建你的 web 游戏
***************************************

这本书马上就要结束了。本章的练习对你是一个真正的挑战。当你完成以后，你就可以算\
是一个能力不错的 Python 初学者了。为了进一步学习，你还需要多读一些书，多写一些程序，\
不过你已经具备进一步学习的技能了。接下来的学习就只是时间、动力、以及资源的问题了。

在本章习题中，我们不会去创建一个完整的游戏，取而代之的是我们会为《习题 42》中的\
游戏创建一个“引擎(engine)”，让这个游戏能够在浏览器中运行起来。这会涉及到将\
《习题 42》中的游戏“重构(refactor)”，将《习题 47》中的架构混合进来，添加自动测试\
代码，最后创建一个可以运行游戏的 web 引擎。

这是一节很庞大的习题。我预测你要花一周到一个月才能完成它。最好的方法是一点一点来，\
每晚上完成一点，在进行下一步之前确认上一步有正确完成。


重构《习题 42》的游戏
=========================

你已经在两个练习中修改了 ``gothonweb`` 项目，这节习题中你会再修改一次。这种修改\
的技术叫做“重构(refactoring)”，或者用我喜欢的讲法来说，叫“修修补补(fixing stuff)”。\
重构是一个编程术语，它指的是清理旧代码或者为旧代码添加新功能的过程。你其实已经\
做过这样的事情了，只不过不知道这个术语而已。这是写软件过程的第二个自然属性。

你在本节中要做的，是将《习题 47》中的可以测试的房间地图，以及《习题 42》中的游戏\
这两样东西归并到一起，创建一个新的游戏架构。游戏的内容不会发生变化，只不过我们\
会通过“重构”让它有一个更好的架构而已。

第一步是将 ``ex47/game.py`` 的内容复制到 ``gothonweb/map.py``\中，然后将
``tests/ex47_tests.py`` 的内容复制到 ``tests/map_tests.py`` 中，然后再次运行
``nosetests``\，确认他们还能正常工作。

.. note:: 

	从现在开始我不会再向你展示运行测试的输出了，我就假设你回去运行这些测试，而且\
	知道怎样的输出是正确的。

将《习题 47》的代码拷贝完毕后，你就该开始重构它，让它包含《习题 42》中的地图。\
我一开始会把基本架构为你准备好，然后你需要去完成 ``map.py`` 和 ``map_tests.py``
里边的内容。

首先要做的是使用 ``Room`` 类来构建基本的地图架构：

.. literalinclude:: ex/ex52/gothonweb/gothonweb/map.py
    :linenos:

你会发现我们的 ``Room`` 类和地图有一些问题：

1. 在进入一个房间以前会打印出一段文字作为房间的描述，我们需要将这些描述和每个房间\
   关联起来，这样房间的次序就不会被打乱了，这对我们的游戏是一件好事。这些描述本来\
   是在 ``if-else`` 结构中的，这是我们后面要修改的东西。
2. 原版游戏中我们使用了专门的代码来生成一些内容，例如炸弹的激活键码，舰舱的选择等，\
   这次我们做游戏时就先使用默认值好了，不过后面的加分习题里，我会要求你把这些功能\
   再加到游戏中。
3. 我为所有的游戏中的失败结尾写了一个 ``generic_death``\，你需要去补全这个函数。\
   你需要把原版游戏中所有的失败结尾都加进去，并确保代码能正确运行。 
4. 我添加了一种新的转换模式，以 ``"*"`` 为标记，用来在游戏引擎中实现“catch-all”动作。

等你把上面的代码基本写好以后，接下来就是引导你继续写下去的自动测试的内容
``tests/map_test.py`` 了：

.. literalinclude:: ex/ex52/gothonweb/tests/map_tests.py
    :linenos:

你在这部分练习中的任务是完成地图，并且让自动测试可以完整地检查过整个地图。\
这包括将所有的 ``generic_death`` 对象修正为游戏中实际的失败结尾。让你的代码成功\
运行起来，并让你的测试越全面越好。后面我们会对地图做一些修改，到时候这些测试\
将保证修改后的代码还可以正常工作。

会话(session)和用户跟踪
===========================

在你的 web 程序运行的某个位置，你需要追踪一些信息，并将这些信息和用户的浏览器关联\
起来。在 HTTP 协议的框架中，web 环境是“无状态(stateless)”的，这意味着你的每一次请求\
和你其它的请求都是相互独立的。如果你请求了页面 A，输入了一些数据，然后点了一个页面 B
的链接，那你在页面 A 输入的数据就全部消失了。

解决这个问题的方法是为 web 程序建立一个很小的数据存储功能，给每个浏览器进程赋予一个\
独一无二的数字，用来跟踪浏览器所作的事情。这个存储通常用数据库或者存储在磁盘上的文件\
来实现。在 ``lpthw.web`` 这个小框架中实现这样的功能是很容易的，以下就是一个这样的例子：

.. literalinclude:: ex/ex52/gothonweb/session_sample.py
    :linenos:

为了实现这个功能，你需要创建一个 ``sessions/`` 文件夹作为程序的会话存储位置，\
创建好以后运行这个程序，然后检查 ``/count`` 页面，刷新一下这个页面，看计数会不会累加\
上去。关掉浏览器后，程序就会“忘掉”之前的位置，这也是我们的游戏所需的功能。\
有一种方法可以让浏览器永远记住一些信息，不过这会让测试和开发变得更难。如果你\
回到 ``/reset/`` 页面，然后再访问 
To make this work, you need to create a ``sessions/`` directory where the
application can put session storage.  Do that,  run this application and
go to ``/count``. Hit refresh and watch the counter go up.  Close
the browser and it *forgets* who you are, which is what we want for the game.
There's a way to make the browser remember forever, but that makes testing
and development harder.  If you then go to ``/reset``, and back to ``/count``
you can see your counter reset because you've killed the session.

Take the time to understand this code so you can see how the session starts
off with the ``count`` equal to 0.  Also try looking at the files in 
``sessions/`` to see if you can open them up.  Here's a Python session where I
open up one and decode it:


.. code-block:: pycon

    >>> import pickle
    >>> import base64
    >>> base64.b64decode(open("sessions/XXXXX").read())
    "(dp1\nS'count'\np2\nI1\nsS'ip'\np3\nV127.0.0.1\np4\nsS'session_id'\np5\nS'XXXX'\np6\ns."
    >>> 
    >>> x = base64.b64decode(open("sessions/XXXXX").read())
    >>> 
    >>> pickle.loads(x)
    {'count': 1, 'ip': u'127.0.0.1', 'session_id': 'XXXXX'}

The sessions are really just dictionaries that get written to disk using ``pickle`` and 
``base64`` libraries.  There are probably as many ways to store and manage sessions as
there are web frameworks, so it's not too important to know how these work.  It does
help if you need to debug the session or potentially clean them out.


创建引擎
==================

You should have your game map working and a good unit test for it.  I now want
to make a simple little game engine that will run the rooms, collect input from
the player, and keep track of where a play is in the game.  We'll be using the
sessions you just learned to make a simple game engine that will:

1. Start a new game for new users.
2. Present the room to the user.
3. Take input from the user.
4. Run their input through the game.
5. Display the results and keep going until they die.

To do this, you're going to take the trusty ``bin/app.py`` you've been hacking on
and create a fully working, session based, game engine.  The catch is I'm
going to make a very simple one with *basic HTML* files, and it'll be up to you to
complete it.   Here's the base engine:

.. literalinclude:: ex/ex52/gothonweb/bin/app.py
    :linenos:

There are even more new things in this script, but amazingly it's an entire
web based game engine in a small file.  The biggest "hack" in the script are
the lines that bring the sessions back, which is needed so that debug mode
reloading works.  Otherwise, each time you hit refresh the sessions will
disappear and the game won't work.

Before you run bin/app.py you need to change your PYTHONPATH environment variable.
Don't know what that is?  I know, it's kind of dumb you have to learn what this
is to run even basic Python programs, but that's how Python people like things.

In your terminal, type:

.. code-block:: console

    export PYTHONPATH=$PYTHONPATH:.

On Windows do:

.. code-block:: console

    set PYTHONPATH=%PYTHONPATH%;.

You should only have to do it once per shell session, but if you get an import error,
then you probably need to do this or you did it wrong.

You should next delete ``templates/hello_form.html`` and ``templates/index.html`` and
create the two templates mentioned in the above code.  Here's a *very* simple 
``templates/show_room.html``:

.. literalinclude:: ex/ex52/gothonweb/templates/show_room.html
    :linenos:

That is the template to show a room as you travel through the game. Next
you need one to tell someone they died in the case that they got to the end
of the map on accident, which is ``templates/you_died.html``:

.. literalinclude:: ex/ex52/gothonweb/templates/you_died.html
    :linenos:

With those in place, you should now be able to do the following:

1. Get the test ``tests/app_tests.py`` working again so that you are testing
   the game.  You won't be able to do much more than a few clicks in the 
   game because of sessions, but you should be able to do some basics.
2. Remove the ``sessions/*`` files and make sure you've started over.
3. Run the ``python bin/app.py`` script and test out the game.

You should be able to refresh and fix the game like normal, and work with 
the game HTML and engine until it does all the things you want it to do.


Your Final Exam
===============

Do you feel like this was a huge amount of information thrown at you all at once?
Good, I want you to have something to tinker with while you build your skills.
To complete this exercise, I'm going to give you a final set of exercises for
you to complete on your own.  You'll notice that what you've written so far
isn't very well built, it is just a first version of the code.  Your task now
is to make the game more complete by doing these things:

1. Fix all the bugs I mention in the code, and any that I didn't mention.
   If you find new bugs, let me know.
2. Improve all of the automated tests so that you test more of the application
   and get to a point where you use a test rather than your browser to check
   the application while you work.
3. Make the HTML look better.
4. Research logins and create a signup system for the application, so people
   can have logins and high scores.
5. Complete the game map, making it as large and feature complete as possible.
6. Give people a "help" system that lets them ask what they can do at each
   room in the game.
7. Add any other features you can think of to the game.
8. Create several "maps" and let people choose a game they want
   to run.  Your ``bin/app.py`` engine should be able to run any map of
   rooms you give it, so you can support multiple games.
9. Finally, use what you learned in Exercises 48 and 49 to create a better
   input processor. You have most of the code necessary, you just need to
   improve the grammar and hook it up to your input form and the ``GameEngine``.

Good luck!

