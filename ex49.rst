习题 49: 创建句子
*****************************

从我们这个小游戏的词汇扫描器中，我们应该可以得到类似下面的列表：

.. code-block:: pycon

    >>> from ex48 import lexicon
    >>> print lexicon.scan("go north")
    [('verb', 'go'), ('direction', 'north')]
    >>> print lexicon.scan("kill the princess")
    [('verb', 'kill'), ('stop', 'the'), ('noun', 'princess')]
    >>> print lexicon.scan("eat the bear")
    [('verb', 'eat'), ('stop', 'the'), ('noun', 'bear')]
    >>> print lexicon.scan("open the door and smack the bear in the nose")
    [('error', 'open'), ('stop', 'the'), ('noun', 'door'), ('error', 'and'),
    ('error', 'smack'), ('stop', 'the'), ('noun', 'bear'), ('stop', 'in'),
    ('stop', 'the'), ('error', 'nose')]
    >>> 

现在让我们把它转化成游戏可以使用的东西，也就是一个 Sentence 类。

如果你还记得学校学过的东西的话，一个句子是由这样的结构组成的：

    主语(Subject) + 谓语(动词 Verb) + 宾语(Object)

很显然实际的句子可能会比这复杂，而你可能已经在英语的语法课上面被折腾得够呛了。
我们的目的，是将上面的元组列表转换为一个 Sentence 对象，而这个对象又包含主谓宾
各个成员。

匹配(Match)和窥视(Peek)
==============

为了达到这个效果，你需要四样工具：

1. 循环访问元组列表的方法，这挺简单的。
2. 匹配我们的主谓宾设置中不同种类元组的方法。
3. 一个“窥视”潜在元组的方法，以便做决定时用到。
4. 跳过(skip)我们不在乎的内容的方法，例如形容词、冠词等没有用处的词汇。

我们使用 peek 函数来查看元组列表中的下一个成员，做匹配以后再对它做下一步动作。\
让我们先看看这个 peek 函数：

.. code-block:: python

    def peek(word_list):
        if word_list:
            word = word_list[0]
            return word[0]
        else:
            return None
        
很简单。再看看 match 函数：

.. code-block:: python

    def match(word_list, expecting):
        if word_list:
            word = word_list.pop(0)

            if word[0] == expecting:
                return word
            else:
                return None
        else:
            return None

还是很简单，最后我们看看 skip 函数:

.. code-block:: python

    def skip(word_list, word_type):
        while peek(word_list) == word_type:
            match(word_list, word_type)

以你现在的水平，你应该可以看出它们的功能来。确认自己真的弄懂了它们。


句子的语法
====================

With our tools we can now begin to build Sentence objects from our list of tuples.
What we do is a process of:

1. Identify the next word with ``peek``.
2. If that word fits in our grammar, we call a function to handle that part 
   of the grammar, say ``parse_subject``.
3. If it doesn't, we ``raise`` an error, which you will learn about in this lesson.
4. When we're all done, we should have a Sentence object to work with in our game.

The best way to demonstrate this is to give you the code to read, but here's where
this exercise is different from the previous one:  You will write the test for the
parser code I give you.  Rather than giving you the test so you can write the code,
I will give you the code, and you have to write the test.

Here's the code that I wrote for parsing simple sentences using the ``ex48.lexicon``
module:

.. literalinclude:: ex/ex49.py

A Word On Exceptions
====================

You briefly learned about exceptions, but not how to raise them.  This code
demonstrates how to do that with the ``ParserException`` at the top.  Notice
that it uses classes to give it the type of ``Exception``.  Also notice the use
of ``raise`` keyword to raise the exception.

In your tests, you will want to work with these exceptions, which I'll show you how 
to do.


What You Should Test
====================

For Exercise 49 is write a complete test that confirms everything
in this code is working.  That includes making exceptions happen by giving it
bad sentences.

Check for an exception by using the function ``assert_raises`` from the nose
documentation.  Learn how to use this so you can write a test that is
*expected* to fail, which is very important in testing.  Learn about this
function (and others) by reading the nose documentation.

When you are done, you should know how this bit of code works, and how
to write a test for other people's code even if they do not want you to.  Trust me,
it's a very handy skill to have.

Extra Credit
============

1. Change the ``parse_`` methods and try to put them into a class rather than 
   be just methods.  Which design do you like better?
2. Make the parser more error resistant so that you can avoid annoying your
   users if they type words your lexicon doesn't understand.
3. Improve the grammar by handling more things like numbers.
4. Think about how you might use this Sentence class in your game to do more fun
   things with a user's input.


